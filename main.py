# This is a sample Python script.

# Press Shift+F10 to execute it or replace it with your code.
# Press Double Shift to search everywhere for classes, files, tool windows, actions, and settings.


def print_hi(name):
    # Use a breakpoint in the code line below to debug your script.
    print(f'Hi, {name}')  # Press Ctrl+F8 to toggle the breakpoint.


# Press the green button in the gutter to run the script.
if __name__ == '__main__':
    print_hi('PyCharm')

# See PyCharm help at https://www.jetbrains.com/help/pycharm/





# days = ('пн', 'вт', 'ср', 'чт', 'пт', 'сб', 'вс')  # кортеж
# steps = [1500, 3445, 13222, 10000, 12555, 1300, 6000]  # список
#
# result = []



# Как сравнить ВСЕ элементы друг с другом? Например, есть два списка.
#
# lst_1 = [2,4,8,16,12]
# lst_2 = [4,6,12,1,8]
# Создаем пустой список. Создаем цикл для первого списка. Добавляем условие: если i есть во втором списке то добавляем его в третий список.
#
# lst_3 = []
#
# for i in lst_1:
#     if i in lst_2:
#         lst_3.append(i)
# print(lst_3)
# Результат: [4,12,8]


#_______________________________________________
# Вычислите и напечатайте количество одинаковых элементов в коллекциях num_string_1 и num_string_2.

num_string_1 = '100 13 2 143 12 3 55 4 64 18 56'
num_string_2 = '234 2 56 432 3 100 12 99 43 18 31 64'

str_to_set_1 = num_string_1.split()
str_to_set_2 = num_string_2.split()

num_string_3 = set(str_to_set_1) & set(str_to_set_2)
print(len(num_string_3))

print()
print()
#______________________________________________

# Антон получил в ответ от сервера перечень ID клиентов в виде строки,
# где ID  разделены пробелами. Его задача — удалить дубликаты и отсортировать список ID по возрастанию.
# Напишите программу, которая поможет Антону формировать такие списки.
# Если в списке будет найден дублирующийся ID — программа должна вывести
# в терминал сообщение «Найден дубликат ID <значение_id>».

id_string = '32 48 2 6 14 58 2 88 9 14 123 48 3 17 42 42 7'
empty_set = set()
num_set = set()  # множество для числовых значений
split_string = id_string.split()  # преобразование строки в список
#print(split_string)


for num in split_string:
    if num in empty_set:
        print(f'Найден дубликат ID {num}')
    else:
        empty_set.add(num)
        num_set.add(int(num))   # преобразование строк в числа

num_set_sorted = sorted(num_set)
print(num_set_sorted)

print()
print()
#_________________________________________________

# Функция-упаковщик zip() принимает в качестве аргументов итерируемые объекты,
# а возвращает объект типа zip — это коллекция кортежей.
# Каждый из кортежей содержит элементы исходных коллекций с одинаковыми индексами.

# Однако обращаться к элементам zip-объекта можно точно так же, как и к элементам любой другой последовательности.
# Объекты типа zip — итерируемые.

# Переберите в цикле элементы объекта movies_info и напечатайте их.

movie_ratings = [4.7, 5.0, 4.3, 4.0]
movies = ['Матрица', 'Хакеры', 'Трон', 'Кибер']

movies_info = zip(movies, movie_ratings)

for films in movies_info:
    print(films)

print()
print()
#_______________________________________________


movies = {
    'Матрица': {'rating': '4.7', 'review': 'Фильм крут'},
    'Хакеры':  {'rating': '4.5', 'review': 'Смотреть можно'},
    'Трон':  {'rating': '3.8', 'review': 'Смотреть можно'},
    'Кибер':  {'rating': '2.5', 'review': 'Так себе киношечка'},
    'Пятая власть':  {'rating': '4.1', 'review': 'Смотреть можно'},
}

hackers = movies['Хакеры']

print(hackers['rating'], hackers['review'])


print()
print()
#_______________________________________________


# Онлайн-кинотеатр присылает Антону перечень фильмов, рекомендованных к просмотру.
# Помогите Антону выбрать фильмы с высоким рейтингом и добавить в избранное.

# Если рекомендованный фильм имеет рейтинг ниже 4.0 — удалите его из словаря recommended_movies.

# При этом программа должна вывести сообщение
# Фильм "<название_фильма>" не интересен: "<отзыв_о_фильме>". Фильм удалён из рекомендаций.

# Все фильмы с рейтингом выше 4.0 программа должна добавить в словарь
# с избранными фильмами favorite_movies и вывести сообщение

# У фильма "<название_фильма>" хороший отзыв: "<отзыв_о_фильме>". Фильм добавлен в избранное.
# Напечатайте получившуюся коллекцию избранных фильмов.

favorite_movies = {}

recommended_movies = {
    'Хенкок': {'rating': 4.5, 'review': 'Смотреть можно'},
    'Матрица': {'rating': 4.7, 'review': 'Фильм крут'},
    'Кибер': {'rating': 2.5, 'review': 'Так себе киношечка'},
    'Трон': {'rating': 3.8, 'review': 'Так себе киношечка'},
    'Мстители': {'rating': 4.7, 'review': 'Фильм крут'},
    'Хакеры':  {'rating': 4.5, 'review': 'Смотреть можно'}
}
recommended_movies_copy = recommended_movies.copy()


# место для вашего кода

for movie, info in recommended_movies.items():
    rating = info['rating']  # обращение к элементу словаря по ключу - передаст в переменную rating = 4.5, 4.7 ...
    review = info['review']  # обращение к элементу словаря по ключу - передаст в переменную review = 'Фильм крут', ...
    # for value in info.values():
    if rating < 4.0:
        print(f'Фильм "{movie}" не интересен: "{review}". Фильм удалён из рекомендаций.')
    # del recommended_movies_copy[movie]
    if rating > 4.0:
        favorite_movies[movie] = info
        print(f'У фильма "{movie}" хороший отзыв: "{review}". Фильм добавлен в избранное.')

recommended_movies = favorite_movies

print(favorite_movies)

# for movie, info in recommended_movies.items():
#     rating = info['rating']  # обращение к элементу словаря по ключу - передаст в переменную rating = 4.5, 4.7 ...
#     review = info['review']  # обращение к элементу словаря по ключу - передаст в переменную review = 'Фильм крут', ...
#     #for value in info.values():
#     if rating < 4.0:
#         print(f'Фильм {movie} не интересен: {review}. Фильм удалён из рекомендаций.')
#     del recommended_movies_copy[movie]
#     if rating > 4.0:
#         favorite_movies[movie] = rating
#         print(f'У фильма {movie} хороший отзыв: {review}. Фильм добавлен в избранное.')
#
# print(favorite_movies)

print()
print()
#_______________________________________________

# Функция get_mean() получает на вход список чисел.
# Напишите код функции так, чтобы она возвращала среднее арифметическое чисел из полученного списка.
# Вызовите функцию get_mean() с аргументом num_lst; напечатайте результат вызова,
# округлив его до двух знаков после запятой.


def get_mean(values):
    summa = 0
    for num in num_lst:
        summa += num

    mean_val = summa / len(num_lst)
    return mean_val


# Список значений для теста
num_lst = [3, 6, 5, 7, 9, 1]
get_mean(num_lst)
print("{:.2f}".format(get_mean(num_lst)))   # округление до 2 знаков

print()
print()
#____________________________________________________________


# Функция принимает в качестве аргументов начальное и конечное значение диапазона
# и неопределённое количество чисел для проверки.

# Напишите функцию, которая вернёт список чисел, попадающих в установленный диапазон.
# Если значение находится вне диапазона функция должна печатать сообщение «Число за границами диапазона».
# Допишите функцию test_range() так, чтобы она:
# принимала в качестве аргументов:
# начальное и конечное значение диапазона,
# неопределённое количество чисел для проверки;
# формировала список из чисел, которые попадают в установленный диапазон;
# для значений, которые находится вне пределов диапазона, печатала сообщение «Число за границами диапазона»;
# возвращала список чисел, попадающих в установленный диапазон.

def test_range(start, end, *args):
    res_list = []
    res_list2 = []
    for arg in args:
        if start < arg < end:
            res_list.append(arg)
        else:
            res_list2.append(arg)
            print(f'Число за границами диапазона')
    return res_list

start = 4
end = 12
print(test_range(start, end, 5, 16, 32, 6, 7, 1))

print()
print()
#_____________________________________________________________

# Импортируйте модуль и используйте переименование
import datetime as dt

# Запишите в переменную объект типа хранящего
# и дату, и время
now_date_time = dt.datetime.now()

print(now_date_time)

print()
print()
#______________________________________________________________


# Лера и Максим очень любят отмечать дни рождения. Им нужна программа, которая будет определять,
# сколько дней осталось до праздника.
# Лера родилась 16.05.2015, а Максим — 16.12.2011.
# В модуле datetime есть тип данных, который хранит только дату, без времени суток.
# Импортируйте и переименуйте модуль datetime.
# Найдите в документации нужный тип данных.
# Создайте две переменные этого типа: запишите в них даты рождения Леры и Максима.
# Напечатайте значения получившихся переменных.

# Импортируйте модуль и используйте переименование
import datetime as dt
# Запишите в переменные даты рождения детей
lera_birthday = dt.date(2015, 5, 16)
maxim_birthday = dt.date(2011, 12, 16)

print(lera_birthday)
print(maxim_birthday)

today = dt.date.today()
print(today)

print()
print()
#____________________________________________________________________


#4.
# Теперь можно вычислить, сколько дней осталось до дня рождения Максима и Леры.
# Чтобы получить количество дней, оставшихся до дня рождения — нужно сравнить сегодняшнюю дату с датой дня рождения в текущем году. Но в переменных хранится дата рождения, она в прошлом. В дате рождения нужно заменить год на текущий.
# Из объекта типа date можно получить значения года, месяца или дня через точечную нотацию.
# Из переменной today получите значение текущего года и запишите его в переменную today_year.
# В объектах типа date можно заменить значение дня, месяца или года и для этого есть специальный метод. Подставьте в даты рождения значения текущего года.
#  После этого программа будет знать даты дней рождения в этом году.
# Осталось найти разницу между сегодняшним днём и днём рождения.
#  Объекты date поддерживают операции разности. Если день рождения в этом году уже прошёл — результат вычислений будет отрицательным. Не беда, исправим позже.
# Запишите количество дней, оставшихся до дня рождения, в переменные lera_days_left и maxim_days_left соответственно. Эти значения должны быть напечатаны.

import datetime as dt

lera_birthday = dt.date(2015, 5, 16)
maxim_birthday = dt.date(2011, 12, 16)

today = dt.date.today()

# Обратитесь к значению года
# текущей даты через точечную нотацию
today_year = today.year
print(today_year)

# Переопределите значение года на текущий
# для дней рождений ребят
lera_birthday = lera_birthday.replace(year=today_year)
maxim_birthday = maxim_birthday.replace(year=today_year)
print(lera_birthday, maxim_birthday)

# Получите разницу между днями рождения и текущей датой
lera_days_left = lera_birthday - today
maxim_days_left = maxim_birthday - today

print(lera_days_left.days)
print(maxim_days_left.days)


print()
print()
#_________________________________________________________________

# 5
# Код стал большим, и в нём стали повторяться функциональные блоки. Чтобы избежать повторов — соберите код в функцию.
# Функция должна называться get_days_to_birthday и принимать параметр date_birthday:
# def get_days_to_birthday(date_birthday)
# Функция get_days_to_birthday() получает на вход дату рождения определённого человека.
# Функция get_days_to_birthday() не должна ничего печатать, она должна возвращать количество дней,
# оставшихся до дня рождения в этом году. Уберите из кода print() и добавьте return <количество_дней_до_дня_рождения>.
# Вызовите функцию два раза: в первом вызове передайте в функцию день рождения Леры, во втором — день рождения Максима.
# Напечатайте результат каждого вызова.

# 6
# Если день рождения в этом году уже прошёл — функция get_days_to_birthday() вернёт отрицательное значение.
# Но все хотят знать, долго ли ждать новых подарков, а не сколько времени прошло после праздника.
# Если date_birthday для текущего года меньше today — значит, день рождения в этому году уже прошёл.
# В этом случае вычислите количество дней, оставшихся до дня рождения, который будет в следующем году.

import datetime as dt

lera_birthday = dt.date(2015, 5, 16)
maxim_birthday = dt.date(2011, 12, 16)


def get_days_to_birthday(date_birthday):
    today = dt.date.today()
    today_year = today.year

    date_birthday = date_birthday.replace(year=today_year)
    date_days_left = (date_birthday - today).days

    if date_birthday < today:
        next_date_birthday = date_birthday.replace(year=today_year+1)
        #next_year = (next_date_birthday - today).days
        #print(next_year)
        date_days_left = (next_date_birthday - today).days  # разность между сегодняшней датой и датой дня рождения в будущем году.
    return date_days_left


print(get_days_to_birthday(lera_birthday))
print(get_days_to_birthday(maxim_birthday))


print()
print()
#___________________________________________________________
























